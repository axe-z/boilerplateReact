<!DOCTYPE html><html><head><meta charset="UTF-8"><title>React</title><link rel="icon" type="image/png" href="favicon.png"><link href="app.css?eae6c2a28275db8d7e78" rel="stylesheet"></head><body><!-- <h1>React</h1> --><div id="MainInterface"></div><div id="app"></div><div class="notes"><div class="section"><h2>React the notes</h2><li>A la base on a juste un render a lancer pour avoir du jsx a l ecran</li><li>React.createClass vs extends React.Component voir lien ici : :::::<a href="http://stackoverflow.com/documentation/reactjs/6371/react-createclass-vs-extends-react-component#t=201611112010580710903"></a></li><li>seulement un container doit etre retourné.</li><li>componentDidMount est une maniere d 'avoir acces au debut '</li><li>lui suggere de faire une variable avec nos props et les pointer vers this. props. valeur et dans le jsx utiliser que le nom de variable, ca fait du sens...</li><li>Les refs: permet de mettre un hook, pour acceder a un tag, et en tirer sa valeur par exemple. refs est un objet, et on accede a ses nom par dot notation</li><li>le state est l objet qui produit un refresh, doit etre creer d'avance, les props eux se font initialiser dans le render , sont read only, et mis sur le component terminé, le state est dans le corps du component et est read , write. BRef un component ne modifie pas ses props, mais modifie continuellement son state.</li><li>On les creer avec getInitialState en createClass, en es6, juste l object dans le constructor.</li><li>il est possible de faire des raccorci, puisque props est une onbjet let p = this.props , ensuite p.nom == this.props.nom</li><li>deux function sont importante ici a present.getInitialState et getInitialState, function qui return un obj de key -> value</li></div><div class="section"><h2>Animer React avec Tweenmax</h2><li>Dans componentDidMount, on doit selectionner le node ( le contenant unique du component) node = ReactDOM findDOMNode (this)</li><li>pour animer qu un seul des children, on doit le trouver ndas l index de children. et en faire une variable.</li><li>Ensuite , meme chose qued habite avec GSAP</li></div><div class="section"><h2>Suite React, avoir plusieurs components</h2><li>Quand et ou diviser ses components, ici la form devrait etre ailleurs, le greeting, l autre.</li><li>il est suggere de faire une version statique bien divisee au depart et ensuite ajouter les fonctionnalites.</li><li>Decider si prop ou state: simplement se demander si une valeur sera modifiee, si oui, STATE, sinon, props.</li></div><div class="section"><h2>Envoyer du data d'un component externe au container</h2><li>Le container doit par exemple, sur un onchange, ou submit, appeler une function locale, cette fonction locale elle doit traiter le data une fois fait, doit la passer au container (on parle du component prinicipale) par un propriete, une prop.</li><li>dans l'externe on a ici par exemple une fonction onFormSubmit , cette fonction pour envoyer ca au container a l'aide d une props function</li><li>dans l'instance du component externe dans le container nomducomponentexterne on y met une props qui elle meme lance une function locale sur le contianer, qui change le state pour creer l ajustement , le rafraichissement.</li></div><div class="section"><h2>Presention component VS container component</h2><li>Un presentation component est un componenet sans state, il ne fait qu afficher ses props.</li><li>un container compo. lui a ses state et va avoir les methodes qui s en suivent</li><li>Si on contruit un objet pour les valeurs de state a changer, au lieu de faire des key value, on peut passer l object complet.</li></div><div class="section"><h2>division des components</h2><li>Il devient plus facile de lire les fichieers une fois separe. faire un folder component, ensuite , importer react dans les fichiers du meme nom que les component</li><li>des const doivent se faire exporter au debut sans default ou a la fin avec le default, et non pas au moment de sa creation avec default. default est un seul export par module</li></div><div class="section"><h2>Routing</h2><li>le contenant est le Router, dans lui des routes , et les route sont logique a l ecran, dans le main,si on veut garder, mais aller a une autre page qui demande a ce que main reste, on fait le lien entre les deux bout de main et y mettre /about. l autre props est component et appelle le nom du component que l on veut a ce path.</li><li>IndexRoute, est pour celui par defaut si on veut, si le hash n'est pas juste, mettons que je tape abOt au lieu d about, ca ira a l index route. Compliquer, mais si on avait que des route, le / ne chargerait rien, mais la il a un children , dans l indexroute. Donc le indexroute devient le par defaut... avec indexroute s appelait defaultroute.. ce qui etait plus clair</li><li>Link au lieu de a link, en majuscule le link, mais il est possible d'utiliser des a avec href de #/about , et ca fera le meme chemin. On utilise Link parce que nous avons la possibilite de stylyser specifiquement pour la page que l on veut.</li><li>Aussi avec actviveClass, on peut determiner le defaut, et le style.</li><li>Quand on utilise indexRoute, dans le router, sur le component en question, le lien du nav sera toujours actif avec Link, il faut utiliser indexLink</li></div><div class="section"><h2>Es6 promises</h2><li>Voici un leger rappel sur les promesses</li><pre><code>

     function addPromesse(a,b){
      return new Promise((res,rej) => {
        if ((typeof a === 'number') && (typeof b === 'number')) {
             res( a + b)  //ce que l on fait avec les deux var.
        } else {
          rej (' erreur')
        }
      }) ;
     }

     addPromesse(2,21).then(sum => {
       console.log(sum)
     }).catch(err => {
       console.log(err)
     })

     addPromesse(2,"b").then(sum => {
       console.log(sum)
     }).catch( err => {
       console.log('oups' + err )
     })
  </code></pre></div><div class="section"><h2>Linker tout..</h2><li>La form onsubmit lance un func qui elle valide le data, et l envois a une func qui sera une props sur l elelment, qui elle meme lancera un handleSearch. elle recoit le data, et ici deviendra un state, et pour modifier, il faut des states.</li><li>Ces state la pour les passer, on utilise la destrucration = le state, et le passe en props. le componenet qui recoit, peut lui aussi destructurer les state, mais rendu la , ils sont des props. Je me comprendrai jamais.</li><pre><code>

  </code></pre></div><div class="section"><h2>Le fetch API</h2><li>le point du fetch, c est qu il recoit du data, mais il sait pas quoi, res.json() est la cle et fait l object.</li><li>ensuite on suit le chemin tout simplement vers ce que l on a de besoin.</li><pre><code>


  return fetch(requestUrl)
  .then(function(res){
    return res.json()  //mets le blob en json
  }).then(res => {
    if(res.cod && res.message){
      throw new Error(res.message)
    } else {
    console.log(res)
   return Math.round(res.main.temp)   //patch d anl object.
  }}).catch(err => {
       console.log(err)    //si err.
    });
  }
getTemp('laval') retourne 22 ..

  </code></pre></div><div class="section"><h2>Retourner conditionnelement son jsx</h2><li>il est possible de decider si on retourne ci ou ca, avec une function dans la portion render, avant le return.</li><li>ca peut etre tel compoenent, ou celui la, il s agit seulement dnas le return entre parenthese jsx, de lancer la fu nction qui fait le if, et determine quoi montrer</li><li></li></div><div class="section"><h2>Ajout des source-maps</h2><li>Dans config de webpack devtool: 'source-map' nous donne maintenant notre code dans la console et pas le code transformé, ca deveient bcp plus simple pour les erreurs.</li></div><div class="section"><h2>Stateless functionnal component</h2><li>Qaund un componenet est plus simple, il est preferable d utiliser un SFC.</li><li>on ne peut y mettre de refs, de methode de lifecycle non plus, snapppp.</li><pre><code>

  </code></pre></div><div class="section"><h2>GIT</h2><li>VOIR LES VIDEOS DANS THE COMPLETE REACT WEB APP COURSE VIDEO 40 A 45</li><li>Pour installer git, dans le folder du project, taper git init dans le terminal , un fichier sera creer, qu on voit pas</li><li>git status, permet de voir ou en est le git, et au depart aucun fichier n'est surveille, on ne veut seulement pas node-moudle</li><li>.gitignore que l on doit creer au root, et y mettre ce qu'on ne veut pas tracker : .DS_Store , bs-config.json et node_modules/</li><li>Si on relance git status, ceux ci ne sont plus present</li><li>Maintenant pour faire un commit, on tape: git add .gitignore pour ajouter a la liste verte se fichier.</li><li>Maintenant pour eviter d avoir a tout taper, on peut seulement taper : GIT ADD . avec le point, on ajoute tous les fichier non-black listé par le git ignore. refaire git status pour voir</li><li>Tout est maintenant vert.Mais rien a raiment savé</li><li>Maintenant pour sauvegarder : en minuscule: GIT COMMIT -m 'Commit Initial' , dans le string, on met simplement un description, si mose ajour , bug reparation, ou peu importe.</li><li>la liste des fichiers sera a l ecran , refaire git status et la liste des fichier modifiers depuis y sera, icil index a changer parce que je tappe, et celui, le index fait par webpack aussi...</li><li>Donc chaque fois qu on touche un fichier, il s ajoutera a la liste pas updatees rouge.</li><li>on pourrait rfaire les memes etapes, mais : GIT COMMIT -A -M 'UPDATE' , ici j'ai eu a identifier l ordi.</li><li>Si un fichier est ajouté, on doit cependant l ajouter avec git add .</li><li>j ai fait un readme, donc je doit refaire git add .</li><br><br><br><h2>Dans Github</h2><li>compte axe-z, on doit dnas les settings alleer activer sa cle SSH, ce qui permet d associer les data et le compte.</li><li>pour ne pas a avoir a taper, nom et password a chaque push, la cle est importante.</li><li>pour se rendre a sa cle sur son ordi, dans le termianl tapper: ls -al ~/.ssh</li><li>id_rsa , est la cle privee.</li><li>id_rsa.pub est la cle public pour le git hub.</li><li>ajouter a son keychain d ordi, la cle git hub: une fois fait (voir videos)</li><li>faire refresh sur git hub, et creer un repo</li><h2>pousser le data la bas</h2><li>git remote add origin https://github.com/axe-z/ReactStuff.git</li><li>ensuite voir si ca fonctionne, y aura pas de confirmation : git remote -v</li><li>edux lien arrivent , un fetch et un push</li><li>origin https://github.com/axe-z/ReactStuff.git (fetch) origin https://github.com/axe-z/ReactStuff.git (push)</li><li>git branch sit si on est sur le master</li><h3>une fois setter</h3><li>seulement faire un : git commit -a -m 'ajout copy'</li><li>une fois fait pour pusher au serveur: git push et c'est fait</li></div><br><br><br><br><br><br><br><div class="section"><h2>Comment ajouter un projet a git</h2><li>arreter webpack</li><li>lancer git init</li><li>lancer git status, pour voir tous les fichier inclut (optionnel)</li><li>lancer git add .</li><li>lancer git commit -a -m 'Initial commit'</li><li>Se rendre sur le site de github pour creer un nouveau repo</li><li>A la page du quick setup, et on veut l option qui push du command line: on copy et paste : git remote add origin https://github.com/axe-z/nomdutruc.git git push -u origin master</li><li>Une fois fait, il s agit seulement de rafraichir la page et le repo devrait maintenant est rempli de mes fichiers.</li><li>fin</li><pre><code>

      pour updater son projet
      dans l ordre :

      git status
      git add .     //si nouveau fichier
      git status
      git commit -am 'message'
      git push

    </code></pre></div><div class="section"><h2>Comment ajouter un projet heroku ( si compte ouvert )</h2><li>Ca se fait dans le termianl sans avoir a aller sur le site de heroku</li><li>D abord lancer heroku create</li><li>pour verifier si ca fonctionne et qu il a ete chercher la bonne chose sur git: git remote -v</li><li>ensuite pour envoyer : git push heroku master</li><li>il ne reste qu a lancer heroku (attendre 10 sec): heroku open</li><pre><code>

  donc :
  heroku create
   git remote -v
  git push heroku master
  heroku open

  </code></pre></div><div class="section"><h2>Pour etre sur d'etre deconnecte de git et heroku, si on reste dnas le meme folder, pour un autre projet.</h2><li>Dans la console, on peut faire rm -rf ./.git/</li><li>Sinon manuellement deleter le rep dans le tree du projet</li><pre><code>
   pour deleter le git, quand on a fini et on veut en partir un autre
     rm -rf ./.git/

  </code></pre></div><div class="section"><h2>Heroku pour la premiere fois</h2><li>Une fois l installer fait, dans le terminal , lancer heroku</li><li>pour savoir qui est loguer: heroku auth:whoami</li><li>tout est installé.</li><li>heroku doit lancer notre site/app, dela meme maniere que nous... avec un script dans npm..</li><li>on doit faire un script qui s appele START, avec un port process.env.PORT , voir server.js</li><li>heroku create , va creer une place pour l app</li><li>de git a heroku : git push heroku master</li><li>heroku open , va ouvrir le site</li><li>fin</li><pre><code>


pour updater son projet
dans l ordre :

git status
git add .     //si nouveau fichier
git status
git commit -am 'message'
git push
git push heroku master ///attendre 10 sec apres.
heroku open

  </code></pre></div><div class="section"><h2>Testing avec MJ</h2><li>puisque react divise en plusieurs pieces, il devient difficile de savoir si un changement entraine pas des sequelles</li><li>Donc il est imporetant d'incorporer du testing avec Mickeal Jacson expect .. oui oui</li><li>https://github.com/mjackson/expect</li><li>voici quelques exemples..</li><pre><code>
disont ...

function add (a,b){
 return a + b;
}
expect(add(2,2)).toEqual(4, 'sinon t as chier ca')
//ou
expect(add(2,2)).toBe(4, 'sinon t as chier ca')


 expect(2).toBeA('number')

 function capitaliser(mot){
  if(!mot || typeof mot !== 'string'){
    mot = ''
  }
   return _.capitalize(mot)
 }

 expect(capitaliser('benoit')).toBe('Benoit')
 expect(capitaliser('benoit')).toBeA('string')

    toExist

    expect(object).toExist([message])
    Asserts the given object is truthy.

    expect('something truthy').toExist()
    Aliases:

    toBeTruthy
    toNotExist

    expect(object).toNotExist([message])
    Asserts the given object is falsy.

    expect(null).toNotExist()
    Aliases:

    toBeFalsy
    toBe

    expect(object).toBe(value, [message])
    Asserts that object is strictly equal to value using ===.

    toNotBe

    expect(object).toNotBe(value, [message])
    Asserts that object is not strictly equal to value using ===.

    toEqual

    expect(object).toEqual(value, [message])
    Asserts that the given object equals value using is-equal.

    toNotEqual

    expect(object).toNotEqual(value, [message])
    Asserts that the given object is not equal to value using is-equal.

    suite sur le site
  </code></pre></div><div class="section"><h2>Unit testing avec Karma</h2><li>installation: npm install karma@0.13.22 karma-chrome-launcher@0.2.2 karma-mocha@0.2.2 karma-mocha-reporter@2.0.0 karma-sourcemap-loader@0.3.7 karma-webpack@1.7.0 mocha@2.4.5 expect@1.14.0 --save-dev</li><li>une fois fait, on doit faire un fichier karma.conf.js , et un rep tests, dans celui ci des fichiers , type genre nom.test.js</li><li>importer expect, et faire un it('shouldbe a test', () 1 tobe 1 .. )</li><li>dans package.json, avoir un script qui lance karam start ...</li><li>npm test et non pas run test</li><pre><code>
  app.test.js :
import expect


describe('App', () => {
  it('should properly run tests', () => {
    expect(1).toBe(1);
  })
})

  </code></pre></div><div class="section"><h2>installer un addons de react</h2><li>npm install react-addons-test-utils --save-dev</li><li>dans le rep tests, on fait un rep components, pour faire un mirroir de notre projet.</li><li>En bas on regarde ce que ca l air</li><li>utiliser mocha:</li><pre><code>
importer
    React from "react";
    ReactDOM from "react-dom";
    expect from 'expect'
    { findDOMNode  } = ReactDOM;
    TestUtils from 'react-addons-test-utils';
    Clock from '../../js/components/Clock'   /// !!!! ON DOIT FAIRE LE PATH COMPLET.... !!!!


  // plus simple
   describe('Clock', () => {
     it('should existe', () => {
       expect(Clock).toExist()
     })

//utile maintenant
    describe('render', () => {
      it('devrait render clock to output', () => {
          let clock = TestUtils.renderIntoDocument(<clock totalsecondes="{62}/">); //appele le component
          let $el = $(findDOMNode(clock));  //on le selectionne avec  jquery
          var actualText = $el.find('.clock-text').text();  //on li le text, et bon ca devrait etre '01:02'

          expect(actualText).toBe('01:02')
      });
    })
  </clock></code></pre></div><div class="section"><h2>Une fois pour tout REACT et comment passer le data</h2><p>Dans le component child, celui qui sera ramener sur la parent, prennons une form child, qui ira sur le parent. Sur la forme il y aura un onSubmit, onChange, qui lancera une fonction justement, dans cette form, on rammasse la valeur des inputs, que l on met dans une variable. Dans cette function onsubmit, on va passer un that.props.nomDefunctionQuiSeraSurLeParent avec en parathese les variables des inputs, en fait le data. en temps que props, sur l'element child il s'agit maintenant de faire un fonction HANDLE qui prend les variables fait sur le child, qui elle va changer un state, qu on aura fait avec getinitialstate sur le parent, disont compteur, qu on initialise a 0. Dans la function handle, on fera un setstate compteur: variableChild qu on a ramener de l autre fonction submit. Fin</p><pre><code>

  </code></pre></div><div class="section"><h2>Lifecylcle pour declencher une action</h2><li>componentDidUpdate permet de voir avec ses deux arguments, la props avanrt , et le state avant, et regarder si y a eu changement</li><li>avec un if statement, on peut regarde si y a eu changement dans le state, si oui, le switch operateur, permet de faire quelque chose avec les different scenarios.</li><li>il y a plein de chose qu on peuty vouloir faire, dans unMount , arreter les intervales, pour pas prendre de jus inutilement.</li><pre><code>
    c omponentWillMount: function()
    c omponentDidMount: function()
    c omponentWillReceiveProps: function(nextProps)
    c omponentWillUpdate: function(nextProps, nextState)
    c omponentDidUpdate: function(prevProps, prevState)
    c omponentWillUnmount: function()
  </code></pre></div><div class="section"><h2>Petit rappel sur scss</h2><li>il est suggere de nommer les fichier scss qui ne sont pas le principale _quelqueChose. scss</li><li>Aussi dans l import, on ne met pas le _ et seulement le nom. END</li></div></div><script type="text/javascript" src="app.js?eae6c2a28275db8d7e78"></script></body></html>